<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>BiDimensionalMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">gis.git</a> &gt; <a href="index.source.html" class="el_package">xgis</a> &gt; <span class="el_source">BiDimensionalMap.java</span></div><h1>BiDimensionalMap.java</h1><pre class="source lang-java linenums">package xgis;

import java.math.BigDecimal;
import java.util.*;
import java.util.concurrent.atomic.AtomicLong;
import java.util.function.Predicate;
import java.util.function.Supplier;

/**
 * The type Bi dimensionalMap is a data type that stores a collection of generic type in a 2 dimensional cartesian plane.
 * This is the primary data-type we will use it to store points in our GIS.
 *
 * @param &lt;T&gt; generic object to be stored in the collection.
 * @author Vinayak Mathur vxm167
 */
public final class BiDimensionalMap&lt;T&gt; {


<span class="fc" id="L19">	private final SortedMap&lt;BigDecimal, SortedMap&lt;BigDecimal, Collection&lt;T&gt;&gt;&gt; points = new TreeMap&lt;&gt;();</span>

	/**
	 * Instantiates a new Bi dimensional map using the given collection of x and y coordinates.
	 * A point is placed on every combination of these coordinates.
	 * The total number of points will be the product of the number of x coordinates and y coordinates.
	 *
	 * @param xCoord the collection of x coordinates.
	 * @param yCoord the collection of y coordinates.
	 */
<span class="fc" id="L29">	BiDimensionalMap(Collection&lt;BigDecimal&gt; xCoord, Collection&lt;BigDecimal&gt; yCoord) {</span>
<span class="fc" id="L30">		Objects.requireNonNull(xCoord, &quot;xCoord cannot be null&quot;);</span>
<span class="fc" id="L31">		Objects.requireNonNull(yCoord, &quot;yCoord cannot be null&quot;);</span>
<span class="fc" id="L32">		Updater up = new Updater();</span>
<span class="fc bfc" id="L33" title="All 2 branches covered.">		for (BigDecimal x : xCoord) {</span>
<span class="fc bfc" id="L34" title="All 2 branches covered.">			for (BigDecimal y : yCoord) {</span>
<span class="fc" id="L35">				up.setCoordinate(new Coordinate(x, y));</span>
<span class="fc" id="L36">				up.add();</span>
<span class="fc" id="L37">			}</span>
<span class="fc" id="L38">		}</span>
<span class="fc" id="L39">	}</span>

	/**
	 * Instantiates a new empty Bi dimensional map.
	 */
<span class="fc" id="L44">	BiDimensionalMap() {</span>
<span class="fc" id="L45">	}</span>

	/**
	 * Returns the collection at the given coordinate of x and y values
	 *
	 * @param x x value
	 * @param y y value
	 * @return the collection at (x,y)
	 */
	public final Collection&lt;T&gt; get(BigDecimal x, BigDecimal y) {
<span class="fc" id="L55">		Objects.requireNonNull(x, &quot;value of x cannot be null&quot;);</span>
<span class="fc" id="L56">		Objects.requireNonNull(y, &quot;value of y cannot be null&quot;);</span>
<span class="fc" id="L57">		return points.get(x).get(y);</span>
	}

	BiDimensionalMap&lt;Rectangle&gt; rectangleMapQuiz(Set&lt;Rectangle&gt; rectangles) {
<span class="nc" id="L61">		Collection&lt;BigDecimal&gt; horizontalCoordinates = new HashSet&lt;&gt;();</span>
<span class="nc" id="L62">		Collection&lt;BigDecimal&gt; verticalCoordinates = new HashSet&lt;&gt;();</span>
<span class="nc" id="L63">		rectangles.forEach(r-&gt;{</span>
<span class="nc" id="L64">			horizontalCoordinates.add(r.left());</span>
<span class="nc" id="L65">			horizontalCoordinates.add(r.right());</span>
<span class="nc" id="L66">			verticalCoordinates.add(r.bottom());</span>
<span class="nc" id="L67">			verticalCoordinates.add(r.top());</span>
<span class="nc" id="L68">		});</span>
<span class="nc" id="L69">		return new BiDimensionalMap&lt;Rectangle&gt;(</span>
			horizontalCoordinates,
			verticalCoordinates);
	}

	/**
	 * Returns the collection at the given coordinate.
	 *
	 * @param coordinate the coordinate
	 * @return the collection at the provided coordinate.
	 */
	public final Collection&lt;T&gt; get(Coordinate coordinate) {
<span class="fc" id="L81">		Objects.requireNonNull(coordinate, &quot;Coordinate cannot be null&quot;);</span>
<span class="fc" id="L82">		return get(coordinate.x(), coordinate.y());</span>
	}

	/**
	 * xSet returns the collection of x coordinates in the map
	 *
	 * @return the set of all x coordinates
	 */
	public final Set&lt;BigDecimal&gt; xSet() {
<span class="fc" id="L91">		return points.keySet();</span>
	}

	/**
	 * ySet returns  the  set  of  y  coordinates  corresponding  to  the
	 * given value of x (or an empty set if no such y value exists)
	 *
	 * @param x the x
	 * @return the set of all y coordinates at x.
	 */
	public final Set&lt;BigDecimal&gt; ySet(BigDecimal x) {
<span class="fc" id="L102">		Objects.requireNonNull(x, &quot;x cannot be null&quot;);</span>
<span class="pc bpc" id="L103" title="1 of 2 branches missed.">		if (!points.containsKey(x)) {</span>
<span class="nc" id="L104">			throw new IllegalArgumentException(&quot;x is not in the map&quot;);</span>
		}
<span class="fc" id="L106">		return points.get(x).keySet();</span>
	}

	/**
	 * Returns the list of coordinates sorted by their compareTo.
	 *
	 * @return the list of coordinates.
	 */
	public final List&lt;Coordinate&gt; coordinateSet() {
<span class="fc" id="L115">		List&lt;Coordinate&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L116">		Set&lt;BigDecimal&gt; xKeys = xSet();</span>
<span class="fc bfc" id="L117" title="All 2 branches covered.">		for (BigDecimal xKey : xKeys) {</span>
<span class="fc" id="L118">			Set&lt;BigDecimal&gt; yKeys = ySet(xKey);</span>
<span class="fc bfc" id="L119" title="All 2 branches covered.">			for (BigDecimal yKey : yKeys) {</span>
<span class="fc" id="L120">				Coordinate c = new Coordinate(xKey, yKey);</span>
<span class="fc" id="L121">				result.add(c);</span>
<span class="fc" id="L122">			}</span>
<span class="fc" id="L123">		}</span>
<span class="fc" id="L124">		result.sort(Coordinate::compareTo);</span>
<span class="fc" id="L125">		return result;</span>
	}

	@Override
	public String toString() {
<span class="fc" id="L130">		StringBuilder result = new StringBuilder();</span>
<span class="fc" id="L131">		Set&lt;BigDecimal&gt; xSet = this.xSet();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">		for (BigDecimal x : xSet) {</span>
<span class="fc" id="L133">			Set&lt;BigDecimal&gt; ySet = this.ySet(x);</span>
<span class="fc bfc" id="L134" title="All 2 branches covered.">			for (BigDecimal y : ySet) {</span>
<span class="fc" id="L135">				result.append(&quot;(&quot;);</span>
<span class="fc" id="L136">				result.append(x.toPlainString());</span>
<span class="fc" id="L137">				result.append(&quot;,&quot;);</span>
<span class="fc" id="L138">				result.append(y.toPlainString());</span>
<span class="fc" id="L139">				result.append(&quot;):&quot;);</span>
<span class="fc" id="L140">				result.append(points.get(x).get(y).toString());</span>
<span class="fc" id="L141">				result.append(&quot;\n&quot;);</span>
<span class="fc" id="L142">			}</span>
<span class="fc" id="L143">		}</span>
<span class="fc" id="L144">		return result.toString();</span>
	}

	/**
	 * Helper method that returns the entire collection
	 *
	 * @return collection of all points
	 */
//	public final List&lt;Collection&lt;T&gt;&gt; collectionList() {
//
//	}

	/**
	 * Helper method that returns the entire collection
	 *
	 * @return collection of all points
	 */
	Collection&lt;InterestPoint&lt;T&gt;&gt; fullCollection() {
<span class="fc" id="L162">		Collection&lt;InterestPoint&lt;T&gt;&gt; result = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L163">		Set&lt;BigDecimal&gt; xKeys = xSet();</span>
<span class="fc" id="L164">		xSet().forEach(x -&gt; {</span>
<span class="fc" id="L165">			ySet(x).forEach(y -&gt; {</span>
<span class="fc" id="L166">				points.get(x).get(y).forEach(marker -&gt; {</span>
<span class="fc" id="L167">					result.add(new InterestPoint&lt;T&gt;(new Coordinate(x, y), marker));</span>
<span class="fc" id="L168">				});</span>
<span class="fc" id="L169">			});</span>
<span class="fc" id="L170">		});</span>
<span class="fc" id="L171">		return result;</span>
	}

	/**
	 * Returns the number of elements in this collection.
	 * If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
	 *
	 * @return the number of elements in this collection
	 */
	public final long collectionSize() {
<span class="nc" id="L181">		Collection&lt;InterestPoint&lt;T&gt;&gt; fullC = fullCollection();</span>
<span class="nc" id="L182">		return fullC.size();</span>
	}

	/**
	 * Returns the number of entries that are stored throughout the map and that satisfy the given predicate.
	 * If this collection contains more than Integer.MAX_VALUE elements, returns Integer.MAX_VALUE.
	 *
	 * @param filter the predicate
	 * @return number of entries that satisfy the predicate
	 */
	public final long collectionSize(Predicate&lt;? super T&gt; filter) {
<span class="fc" id="L193">		Objects.requireNonNull(filter, &quot;filter cannot be null&quot;);</span>
<span class="fc" id="L194">		Collection&lt;InterestPoint&lt;T&gt;&gt; fullC = fullCollection();</span>
<span class="fc" id="L195">		AtomicLong result = new AtomicLong();</span>
<span class="fc" id="L196">		int i = 0;</span>
<span class="fc" id="L197">		List&lt;InterestPoint&lt;T&gt;&gt; arr = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L198">		fullC.forEach((ip) -&gt; {</span>
<span class="fc" id="L199">			arr.add(ip);</span>
<span class="pc bpc" id="L200" title="1 of 2 branches missed.">			if (arr.stream().anyMatch((e) -&gt; e.marker().equals(filter))) {</span>
<span class="nc" id="L201">				result.addAndGet(1);</span>
			}
<span class="fc" id="L203">			arr.clear();</span>
<span class="fc" id="L204">		});</span>
//		for (InterestPoint&lt;T&gt; ip : fullC) {
//			arr.add(ip);
//			if (arr.stream().anyMatch((e) -&gt; e.marker().equals(filter))) {
//				result++;
//			}
//			arr.clear();
//		}
<span class="fc" id="L212">		return result.get();</span>
	}

	/**
	 * Returns an instance of BiDimensionalMap.Updater
	 *
	 * @return the updater
	 */
	public final Updater getUpdater() {
<span class="fc" id="L221">		return new Updater();</span>
	}

	private final void compareInner(BigDecimal x, BigDecimal y, Rectangle rectangle, Updater up) {
<span class="nc bnc" id="L225" title="All 2 branches missed.">		if (y.compareTo(rectangle.bottom()) &gt;= 0 &amp;&amp;</span>
<span class="nc bnc" id="L226" title="All 2 branches missed.">			x.compareTo(rectangle.top()) &lt; 0) {</span>
<span class="nc" id="L227">			up.setCoordinate(new Coordinate(x, y)).setValues(points.get(x).get(y)).add();</span>
		}
<span class="nc" id="L229">	}</span>

	/**
	 * Slice bi dimensional map.
	 *
	 * @param rectangle the rectangle
	 * @return BiDimensionalMap
	 */
	public final BiDimensionalMap&lt;T&gt; slice(Rectangle rectangle) {
<span class="fc" id="L238">		Objects.requireNonNull(rectangle, &quot;rectangle cannot be null&quot;);</span>
<span class="fc" id="L239">		BiDimensionalMap&lt;T&gt; result = new BiDimensionalMap&lt;&gt;();</span>
<span class="fc" id="L240">		Updater up = result.getUpdater();</span>
<span class="fc bfc" id="L241" title="All 2 branches covered.">		for (Coordinate c : coordinateSet()) {</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">			if (rectangle.inside(c)) {</span>
<span class="fc" id="L243">				up.setCoordinate(c);</span>
<span class="fc" id="L244">				up.setValues(get(c));</span>
<span class="fc" id="L245">				up.add();</span>
			}
<span class="fc" id="L247">		}</span>
<span class="fc" id="L248">		System.out.println(&quot;Heres the slice\n&quot; + result.toString());</span>
<span class="fc" id="L249">		return result;</span>
	}

	/**
	 * Add everywhere.
	 *
	 * @param value the value
	 */
	public final void addEverywhere(T value) {
<span class="fc" id="L258">		Objects.requireNonNull(value, &quot;value cannot be null&quot;);</span>
<span class="fc" id="L259">		Updater up = new Updater();</span>
<span class="fc" id="L260">		up.addValue(value);</span>
<span class="fc bfc" id="L261" title="All 2 branches covered.">		for (BigDecimal x : xSet()) {</span>
<span class="fc bfc" id="L262" title="All 2 branches covered.">			for (BigDecimal y : ySet(x)) {</span>
<span class="fc" id="L263">				up.setCoordinate(new Coordinate(x, y));</span>
<span class="fc" id="L264">				up.add();</span>
<span class="fc" id="L265">			}</span>
<span class="fc" id="L266">		}</span>
<span class="fc" id="L267">	}</span>

	/**
	 * The type Updater.
	 */
<span class="fc" id="L272">	public final class Updater {</span>

<span class="fc" id="L274">		private BigDecimal x = BigDecimal.ZERO;</span>
<span class="fc" id="L275">		private BigDecimal y = BigDecimal.ZERO;</span>

<span class="fc" id="L277">		private final Supplier&lt;Collection&lt;T&gt;&gt; collectionFactory = HashSet::new;</span>

<span class="fc" id="L279">		private Collection&lt;T&gt; values = collectionFactory.get();</span>

		/**
		 * Sets x.
		 *
		 * @param x the x
		 * @return the x
		 */
		public final Updater setX(BigDecimal x) {
<span class="nc" id="L288">			Objects.requireNonNull(x, &quot;x cannot be null&quot;);</span>
<span class="nc" id="L289">			this.x = x;</span>
<span class="nc" id="L290">			return this;</span>
		}

		/**
		 * Sets y.
		 *
		 * @param y the y
		 * @return the y
		 */
		public final Updater setY(BigDecimal y) {
<span class="nc" id="L300">			Objects.requireNonNull(y, &quot;y cannot be null&quot;);</span>
<span class="nc" id="L301">			this.y = y;</span>
<span class="nc" id="L302">			return this;</span>
		}

		/**
		 * Sets coordinate.
		 *
		 * @param coordinate the coordinate
		 * @return the coordinate
		 */
		public final Updater setCoordinate(Coordinate coordinate) {
<span class="fc" id="L312">			Objects.requireNonNull(coordinate, &quot;Coordinate cannot be null&quot;);</span>
<span class="fc" id="L313">			coordinate.validate();</span>
<span class="fc" id="L314">			x = coordinate.x();</span>
<span class="fc" id="L315">			y = coordinate.y();</span>
<span class="fc" id="L316">			return this;</span>
		}


		/**
		 * Add value updater.
		 *
		 * @param value the value
		 * @return the updater
		 */
		public final Updater addValue(T value) {
<span class="fc" id="L327">			Objects.requireNonNull(value, &quot;value cannot be null&quot;);</span>
<span class="fc" id="L328">			values.add(value);</span>
<span class="fc" id="L329">			return this;</span>
		}

		/**
		 * Sets values.
		 *
		 * @param values the values
		 * @return the values
		 */
		public final Updater setValues(Collection&lt;T&gt; values) {
<span class="fc" id="L339">			Objects.requireNonNull(values, &quot;new values cannot be null&quot;);</span>
<span class="fc" id="L340">			this.values = values;</span>
<span class="fc" id="L341">			return this;</span>
		}

		/**
		 * Set collection.
		 *
		 * @return the collection
		 */
		public final Collection&lt;T&gt; set() {
<span class="nc bnc" id="L350" title="All 2 branches missed.">			if (points.containsKey(x)) {</span>
<span class="nc" id="L351">				SortedMap&lt;BigDecimal, Collection&lt;T&gt;&gt; temp = points.get(x);</span>
<span class="nc bnc" id="L352" title="All 2 branches missed.">				if (temp.containsKey(y)) {</span>
<span class="nc" id="L353">					temp.put(y, values);</span>
<span class="nc" id="L354">					points.put(x, temp);</span>
<span class="nc" id="L355">					return temp.get(y);</span>
				}
			}

<span class="nc" id="L359">			return null;</span>
		}

		/**
		 * Add boolean.
		 *
		 * @return the boolean
		 */
		public final boolean add() {
<span class="fc" id="L368">			boolean flag = false;</span>
<span class="fc bfc" id="L369" title="All 2 branches covered.">			if (points.containsKey(x)) {</span>
<span class="fc bfc" id="L370" title="All 2 branches covered.">				if (points.get(x).containsKey(y)) {</span>
<span class="fc" id="L371">					Collection&lt;T&gt; prevValues = points.get(x).get(y);</span>
<span class="fc" id="L372">					points.get(x).get(y).addAll(values);</span>
<span class="fc" id="L373">					Collection&lt;T&gt; newValues = points.get(x).get(y);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">					flag = !newValues.equals(prevValues);</span>
<span class="fc" id="L375">				} else {</span>
<span class="fc" id="L376">					points.get(x).put(y, collectionFactory.get());</span>
<span class="fc" id="L377">					points.get(x).get(y).addAll(values);</span>
				}
			} else {
<span class="fc" id="L380">				SortedMap&lt;BigDecimal, Collection&lt;T&gt;&gt; s = new TreeMap&lt;&gt;();</span>
<span class="fc" id="L381">				Collection&lt;T&gt; newValues = collectionFactory.get();</span>
<span class="fc" id="L382">				newValues.addAll(values);</span>
<span class="fc" id="L383">				s.put(y, newValues);</span>
<span class="fc" id="L384">				points.put(x, s);</span>
			}
<span class="fc" id="L386">			return flag;</span>
		}
	}
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.7.202105040129</span></div></body></html>